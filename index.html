<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aetherium: Netzwerk-Rätsel Deluxe</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #00ffaa;
            --node-color: #00ffff;
            --selected-color: #ff00ff;
            --hover-color: #00ffaa;
            --text-color: #ffffff;
            --bg-color: #000000;
            --power-node-color: #ffaa00;
            --speed-node-color: #00ff00;
            --bonus-node-color: #aa00ff;
        }
        
        .dark {
            --primary-color: #00ffaa;
            --node-color: #00ffff;
            --selected-color: #ff00ff;
            --hover-color: #00ffaa;
            --text-color: #ffffff;
            --bg-color: #000000;
            --power-node-color: #ffaa00;
            --speed-node-color: #00ff00;
            --bonus-node-color: #aa00ff;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Inter', sans-serif;
            touch-action: none;
        }
        
        canvas {
            display: block;
            touch-action: none;
        }
        
        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
            z-index: 10;
            display: flex;
            justify-content: space-between;
        }
        
        #score-section {
            flex: 1;
        }
        
        #timer-section {
            text-align: right;
            margin-left: 20px;
        }
        
        #score-display {
            font-size: 24px;
            color: var(--primary-color);
            text-shadow: 0 0 10px rgba(0,255,170,0.5);
        }
        
        #level-display {
            font-size: 18px;
            color: var(--text-color);
            margin-top: 5px;
        }
        
        #combo-display {
            font-size: 16px;
            color: #ff9900;
            margin-top: 5px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        #combo-display.active {
            opacity: 1;
        }
        
        #timer-display {
            font-size: 22px;
            color: #ff6666;
        }
        
        #objective {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 10px;
            border: 1px solid var(--primary-color);
            font-size: 16px;
            color: var(--text-color);
            text-align: center;
            max-width: 90%;
            z-index: 10;
        }
        
        .tutorial {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid var(--primary-color);
            max-width: 90%;
            width: 450px;
            text-align: center;
            z-index: 100;
        }
        
        .button {
            background: var(--primary-color);
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            color: #000;
            font-weight: bold;
            margin-top: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
        }
        
        .button:hover {
            background: #fff;
            transform: scale(1.05);
        }
        
        .level-complete {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid var(--primary-color);
            max-width: 90%;
            width: 450px;
            text-align: center;
            z-index: 100;
            animation: fadeIn 0.5s ease-in;
        }
        
        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #ff5555;
            max-width: 90%;
            width: 450px;
            text-align: center;
            z-index: 100;
            animation: fadeIn 0.5s ease-in;
        }
        
        #power-up-notification {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 8px 15px;
            border-radius: 10px;
            border: 1px solid var(--power-node-color);
            font-size: 16px;
            color: var(--text-color);
            text-align: center;
            max-width: 90%;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        #power-up-notification.visible {
            opacity: 1;
        }
        
        .bonus-points {
            position: absolute;
            font-size: 18px;
            font-weight: bold;
            color: #ffff00;
            pointer-events: none;
            z-index: 1000;
            animation: flyUp 1.5s forwards;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
        }
        
        @keyframes flyUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @media (max-width: 640px) {
            #score-display {
                font-size: 20px;
            }
            
            #level-display {
                font-size: 16px;
            }
            
            #timer-display {
                font-size: 18px;
            }
            
            #objective {
                font-size: 14px;
                padding: 8px 16px;
            }
        }
        
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .loading-text {
            color: var(--primary-color);
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 3px;
            animation: pulse 1.5s infinite;
        }
        
        /* Node type indicator and legend */
        #node-legend {
            position: fixed;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 8px 15px;
            border-radius: 10px;
            border: 1px solid var(--primary-color);
            font-size: 14px;
            color: var(--text-color);
            text-align: center;
            display: flex;
            gap: 15px;
            justify-content: center;
            max-width: 90%;
            z-index: 9;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        /* Settings Panel */
        #settings-button {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background-color: rgba(0,0,0,0.5);
            border: 1px solid var(--primary-color);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 20;
            transition: all 0.3s ease;
        }
        
        #settings-button:hover {
            background-color: rgba(0,255,170,0.2);
        }
        
        #settings-panel {
            position: fixed;
            top: 70px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid var(--primary-color);
            z-index: 20;
            width: 250px;
            display: none;
        }
        
        #settings-panel.visible {
            display: block;
            animation: fadeIn 0.3s ease-in;
        }
        
        .setting-item {
            margin-bottom: 15px;
        }
        
        .setting-label {
            font-size: 14px;
            margin-bottom: 5px;
            display: block;
        }
        
        .setting-control {
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="loading">
        <div class="loading-text">Lädt Aetherium Deluxe...</div>
    </div>
    
    <div id="ui-overlay">
        <div id="score-section">
            <div id="score-display">Score: 0</div>
            <div id="level-display">Level 1</div>
            <div id="combo-display">Combo: x1</div>
        </div>
        <div id="timer-section">
            <div id="timer-display">60s</div>
        </div>
    </div>
    
    <div id="objective">Verbinde die rot blinkenden Knoten, um das Level abzuschließen!</div>
    
    <div id="node-legend">
        <div class="legend-item">
            <div class="legend-color" style="background-color: #ff0000;"></div>
            <span>Ziel</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: var(--power-node-color);"></div>
            <span>Power</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: var(--speed-node-color);"></div>
            <span>Zeit</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: var(--bonus-node-color);"></div>
            <span>Bonus</span>
        </div>
    </div>
    
    <div id="power-up-notification">Power-Up aktiviert: Doppelte Punkte für 10s!</div>
    
    <div id="settings-button">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
        </svg>
    </div>
    
    <div id="settings-panel">
        <div class="setting-item">
            <label class="setting-label" for="difficulty-setting">Schwierigkeitsgrad:</label>
            <select id="difficulty-setting" class="setting-control bg-gray-800 text-white p-2 rounded">
                <option value="easy">Leicht</option>
                <option value="normal" selected>Normal</option>
                <option value="hard">Schwer</option>
            </select>
        </div>
        <div class="setting-item">
            <label class="setting-label" for="particles-setting">Partikeleffekte:</label>
            <select id="particles-setting" class="setting-control bg-gray-800 text-white p-2 rounded">
                <option value="high" selected>Hoch</option>
                <option value="medium">Mittel</option>
                <option value="low">Niedrig</option>
            </select>
        </div>
        <div class="setting-item">
            <label class="setting-label" for="music-volume">Musik:</label>
            <input type="range" id="music-volume" class="setting-control" min="0" max="100" value="50">
        </div>
        <div class="setting-item">
            <label class="setting-label" for="sfx-volume">Sound-Effekte:</label>
            <input type="range" id="sfx-volume" class="setting-control" min="0" max="100" value="70">
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        // --- Imports ---
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
        import { Line2 } from 'three/addons/lines/Line2.js';

        // Dark mode detection
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // --- Global Variables ---
        let scene, camera, renderer, controls, composer;
        let raycaster, mouse, pointerOverCanvas = false;
        const interactableNodes = [];
        const permanentLines = [];
        const tempLines = [];
        const nodeDataMap = new Map();
        let selectedNode = null;
        let hoveredNode = null;
        let isDragging = false;
        let activeLine = null;
        const clock = new THREE.Clock();
        let particles, particleSystem;
        let isInitialized = false;
        let countdownInterval;
        let powerUpTimeout;
        let comboTimeout;
        let difficultySettings = {
            easy: {
                timePerLevel: 90,
                timeBonus: 20,
                scoreMultiplier: 0.8,
                specialNodeChance: 0.2
            },
            normal: {
                timePerLevel: 60,
                timeBonus: 15,
                scoreMultiplier: 1.0,
                specialNodeChance: 0.3
            },
            hard: {
                timePerLevel: 45,
                timeBonus: 10,
                scoreMultiplier: 1.5,
                specialNodeChance: 0.4
            }
        };

        // --- Game State ---
        const gameState = {
            score: 0,
            level: 1,
            targetConnections: [],
            completedConnections: new Set(),
            isLevelComplete: false,
            tutorial: true,
            timeBonus: 0,
            levelStartTime: 0,
            difficulty: 'normal',
            timeRemaining: difficultySettings.normal.timePerLevel,
            combo: 0,
            comboMultiplier: 1,
            powerUps: {
                doublePoints: false,
                slowTime: false,
                magneticNodes: false
            },
            specialNodes: {
                power: [], // Double points
                speed: [], // Extra time
                bonus: []  // Bonus points
            }
        };

        // --- Settings Panel ---
        function setupSettingsPanel() {
            const settingsButton = document.getElementById('settings-button');
            const settingsPanel = document.getElementById('settings-panel');
            
            settingsButton.addEventListener('click', () => {
                settingsPanel.classList.toggle('visible');
            });
            
            // Difficulty setting
            const difficultySetting = document.getElementById('difficulty-setting');
            difficultySetting.value = gameState.difficulty;
            difficultySetting.addEventListener('change', () => {
                gameState.difficulty = difficultySetting.value;
                
                // Update time based on new difficulty
                const newTime = difficultySettings[gameState.difficulty].timePerLevel;
                gameState.timeRemaining = newTime;
                updateTimerDisplay();
            });
            
            // Particles setting
            const particlesSetting = document.getElementById('particles-setting');
            particlesSetting.addEventListener('change', () => {
                const value = particlesSetting.value;
                if (particles && particleSystem) {
                    if (value === 'low') {
                        particles.visible = false;
                        particleSystem.visible = false;
                    } else if (value === 'medium') {
                        particles.visible = true;
                        particleSystem.visible = false;
                    } else {
                        particles.visible = true;
                        particleSystem.visible = true;
                    }
                }
            });
            
            // Close panel when clicking outside
            document.addEventListener('click', (event) => {
                if (settingsPanel.classList.contains('visible') && 
                    !settingsPanel.contains(event.target) && 
                    !settingsButton.contains(event.target)) {
                    settingsPanel.classList.remove('visible');
                }
            });
        }

        function showTutorial() {
            const tutorial = document.createElement('div');
            tutorial.className = 'tutorial';
            tutorial.innerHTML = `
                <h2 style="font-size: 24px; color: var(--primary-color); margin-bottom: 15px;">Willkommen bei Aetherium Deluxe!</h2>
                <p style="margin-bottom: 10px;">Verbinde die rot blinkenden Knoten miteinander, um Energie durch das Netzwerk fließen zu lassen.</p>
                <p style="margin-bottom: 10px;">Je schneller du die Verbindungen herstellst, desto mehr Punkte erhältst du.</p>
                <p style="margin-bottom: 10px;">Spezielle Knoten geben dir Power-Ups:</p>
                <div style="display: flex; justify-content: center; margin: 15px 0; gap: 15px;">
                    <div style="text-align: center;">
                        <div style="width: 20px; height: 20px; background-color: var(--power-node-color); border-radius: 50%; margin: 0 auto;"></div>
                        <p>Doppelte Punkte</p>
                    </div>
                    <div style="text-align: center;">
                        <div style="width: 20px; height: 20px; background-color: var(--speed-node-color); border-radius: 50%; margin: 0 auto;"></div>
                        <p>Extra Zeit</p>
                    </div>
                    <div style="text-align: center;">
                        <div style="width: 20px; height: 20px; background-color: var(--bonus-node-color); border-radius: 50%; margin: 0 auto;"></div>
                        <p>Bonus Punkte</p>
                    </div>
                </div>
                <p style="margin-bottom: 15px;">Baue Combos auf, indem du schnell mehrere Verbindungen erstellst!</p>
                <button class="button" id="start-game">Spiel starten</button>
            `;
            document.body.appendChild(tutorial);

            document.getElementById('start-game').onclick = () => {
                tutorial.remove();
                gameState.tutorial = false;
                gameState.levelStartTime = Date.now();
                startTimer();
            };
        }

        function startTimer() {
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }
            
            gameState.timeRemaining = difficultySettings[gameState.difficulty].timePerLevel;
            updateTimerDisplay();
            
            countdownInterval = setInterval(() => {
                // If time modifier is active, reduce time more slowly
                const timeReduction = gameState.powerUps.slowTime ? 0.5 : 1;
                
                gameState.timeRemaining -= timeReduction;
                updateTimerDisplay();
                
                if (gameState.timeRemaining <= 0) {
                    clearInterval(countdownInterval);
                    showGameOver();
                }
            }, 1000);
        }

        function updateTimerDisplay() {
            const timerDisplay = document.getElementById('timer-display');
            timerDisplay.textContent = `${Math.ceil(gameState.timeRemaining)}s`;
            
            // Change color based on time remaining
            if (gameState.timeRemaining <= 10) {
                timerDisplay.style.color = '#ff0000';
                timerDisplay.style.animation = 'pulse 0.5s infinite';
            } else if (gameState.timeRemaining <= 20) {
                timerDisplay.style.color = '#ff6600';
                timerDisplay.style.animation = 'none';
            } else {
                timerDisplay.style.color = '#ff6666';
                timerDisplay.style.animation = 'none';
            }
        }

        function showLevelComplete() {
            clearInterval(countdownInterval);
            
            const timeBonus = Math.max(0, Math.floor(gameState.timeRemaining * 5));
            const difficultyMultiplier = difficultySettings[gameState.difficulty].scoreMultiplier;
            const levelScore = Math.floor(gameState.level * 100 * difficultyMultiplier);
            const totalScore = levelScore + timeBonus;
            
            gameState.score += totalScore;
            updateUI();

            const levelComplete = document.createElement('div');
            levelComplete.className = 'level-complete';
            levelComplete.innerHTML = `
                <h2 style="font-size: 24px; color: var(--primary-color); margin-bottom: 15px;">Level ${gameState.level} abgeschlossen!</h2>
                <p style="margin-bottom: 10px;">Basis-Punkte: ${levelScore}</p>
                <p style="margin-bottom: 10px;">Zeit-Bonus: ${timeBonus}</p>
                <p style="margin-bottom: 15px; font-size: 20px; font-weight: bold;">Gesamt: ${totalScore} Punkte</p>
                <button class="button" id="next-level">Nächstes Level</button>
            `;
            document.body.appendChild(levelComplete);

            document.getElementById('next-level').onclick = () => {
                levelComplete.remove();
                initializeLevel(gameState.level + 1);
            };
        }

        function showGameOver() {
            const gameOver = document.createElement('div');
            gameOver.className = 'game-over';
            gameOver.innerHTML = `
                <h2 style="font-size: 24px; color: #ff5555; margin-bottom: 15px;">Zeit abgelaufen!</h2>
                <p style="margin-bottom: 10px;">Du hast Level ${gameState.level} erreicht.</p>
                <p style="margin-bottom: 15px; font-size: 22px;">Endpunktzahl: ${gameState.score}</p>
                <button class="button" id="restart-game" style="background-color: #ff5555;">Neues Spiel</button>
            `;
            document.body.appendChild(gameOver);

            document.getElementById('restart-game').onclick = () => {
                gameOver.remove();
                resetGame();
            };
        }

        function resetGame() {
            gameState.score = 0;
            gameState.level = 1;
            gameState.combo = 0;
            gameState.comboMultiplier = 1;
            
            clearPowerUps();
            initializeLevel(1);
        }

        function clearPowerUps() {
            // Clear any active power-ups
            gameState.powerUps.doublePoints = false;
            gameState.powerUps.slowTime = false;
            gameState.powerUps.magneticNodes = false;
            
            // Clear any power-up timeouts
            if (powerUpTimeout) {
                clearTimeout(powerUpTimeout);
            }
            
            // Hide notification
            const notification = document.getElementById('power-up-notification');
            notification.classList.remove('visible');
        }

        function initializeLevel(level) {
            // Clear any active timeouts or intervals
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }
            
            gameState.level = level;
            gameState.targetConnections = [];
            gameState.completedConnections.clear();
            gameState.isLevelComplete = false;
            gameState.levelStartTime = Date.now();
            gameState.specialNodes = {
                power: [],
                speed: [],
                bonus: []
            };

            // Reset all nodes to base state
            interactableNodes.forEach(node => {
                node.userData.isTarget = false;
                node.userData.specialType = null;
                node.material.color.copy(node.userData.baseColor);
                node.material.emissive.copy(node.userData.baseColor);
                node.material.emissiveIntensity = node.userData.baseEmissiveIntensity;
                node.scale.set(1, 1, 1);
            });

            // Remove all permanent connections
            permanentLines.forEach(line => {
                scene.remove(line);
                line.geometry.dispose();
                line.material.dispose();
            });
            permanentLines.length = 0;

            // Create new target connections based on level
            const numConnections = Math.min(2 + Math.floor(level / 2), 7);
            const numTargets = Math.min(numConnections * 2, interactableNodes.length * 0.6);
            const availableNodes = [...interactableNodes];
            const selectedTargets = [];
            
            // Select target nodes
            for (let i = 0; i < numTargets; i++) {
                const randomIndex = Math.floor(Math.random() * availableNodes.length);
                const selectedNode = availableNodes.splice(randomIndex, 1)[0];
                selectedNode.userData.isTarget = true;
                selectedTargets.push(selectedNode);
            }
            
            // Create random non-overlapping connections
            const pairedNodes = new Set();
            for (let i = 0; i < numConnections && selectedTargets.length >= 2; i++) {
                let nodeA, nodeB;
                
                // Keep trying to find a valid pair
                let attempts = 0;
                do {
                    const idxA = Math.floor(Math.random() * selectedTargets.length);
                    nodeA = selectedTargets[idxA];
                    
                    const idxB = Math.floor(Math.random() * selectedTargets.length);
                    nodeB = selectedTargets[idxB];
                    
                    attempts++;
                    if (attempts > 100) break; // Prevent infinite loop
                } while (
                    nodeA === nodeB || 
                    pairedNodes.has(nodeA.uuid) || 
                    pairedNodes.has(nodeB.uuid)
                );
                
                if (attempts <= 100) {
                    pairedNodes.add(nodeA.uuid);
                    pairedNodes.add(nodeB.uuid);
                    gameState.targetConnections.push([nodeA.uuid, nodeB.uuid]);
                }
            }
            
            // Add special nodes
            const specialNodeChance = difficultySettings[gameState.difficulty].specialNodeChance;
            const unpaired = availableNodes;
            
            // Power nodes (double points)
            const powerNodeCount = Math.floor(Math.random() * 2) + 1; // 1-2 power nodes
            for (let i = 0; i < powerNodeCount && unpaired.length > 0; i++) {
                if (Math.random() < specialNodeChance) {
                    const idx = Math.floor(Math.random() * unpaired.length);
                    const node = unpaired.splice(idx, 1)[0];
                    node.userData.specialType = 'power';
                    gameState.specialNodes.power.push(node.uuid);
                }
            }
            
            // Speed nodes (extra time)
            const speedNodeCount = Math.floor(Math.random() * 2) + 1; // 1-2 speed nodes
            for (let i = 0; i < speedNodeCount && unpaired.length > 0; i++) {
                if (Math.random() < specialNodeChance) {
                    const idx = Math.floor(Math.random() * unpaired.length);
                    const node = unpaired.splice(idx, 1)[0];
                    node.userData.specialType = 'speed';
                    gameState.specialNodes.speed.push(node.uuid);
                }
            }
            
            // Bonus nodes (bonus points)
            const bonusNodeCount = Math.min(level, 3); // More bonus nodes in higher levels
            for (let i = 0; i < bonusNodeCount && unpaired.length > 0; i++) {
                if (Math.random() < specialNodeChance * 1.5) { // Higher chance for bonus nodes
                    const idx = Math.floor(Math.random() * unpaired.length);
                    const node = unpaired.splice(idx, 1)[0];
                    node.userData.specialType = 'bonus';
                    gameState.specialNodes.bonus.push(node.uuid);
                }
            }

            updateUI();
            startTimer();
        }

        function checkLevelComplete() {
            const allConnectionsMade = gameState.targetConnections.every(([nodeA, nodeB]) => {
                return gameState.completedConnections.has(`${nodeA}-${nodeB}`) || 
                       gameState.completedConnections.has(`${nodeB}-${nodeA}`);
            });

            if (allConnectionsMade && !gameState.isLevelComplete) {
                gameState.isLevelComplete = true;
                showLevelComplete();
            }

            updateUI();
        }
        
        function updateCombo() {
            // Increase combo when making connections quickly
            gameState.combo++;
            gameState.comboMultiplier = Math.min(1 + (gameState.combo * 0.25), 3); // Max 3x multiplier
            
            // Reset combo after 3 seconds of inactivity
            if (comboTimeout) {
                clearTimeout(comboTimeout);
            }
            
            comboTimeout = setTimeout(() => {
                gameState.combo = 0;
                gameState.comboMultiplier = 1;
                updateUI();
                
                // Hide combo display
                const comboDisplay = document.getElementById('combo-display');
                comboDisplay.classList.remove('active');
            }, 3000);
            
            updateUI();
            
            // Show combo display
            const comboDisplay = document.getElementById('combo-display');
            comboDisplay.classList.add('active');
        }
        
        function activatePowerUp(type) {
            const notification = document.getElementById('power-up-notification');
            
            // Clear any existing timeouts
            if (powerUpTimeout) {
                clearTimeout(powerUpTimeout);
            }
            
            switch (type) {
                case 'power':
                    gameState.powerUps.doublePoints = true;
                    notification.textContent = 'Power-Up aktiviert: Doppelte Punkte für 10s!';
                    notification.style.borderColor = 'var(--power-node-color)';
                    
                    powerUpTimeout = setTimeout(() => {
                        gameState.powerUps.doublePoints = false;
                        notification.classList.remove('visible');
                    }, 10000);
                    break;
                    
                case 'speed':
                    // Add extra time
                    const bonusTime = difficultySettings[gameState.difficulty].timeBonus;
                    gameState.timeRemaining += bonusTime;
                    notification.textContent = `Power-Up aktiviert: +${bonusTime} Sekunden!`;
                    notification.style.borderColor = 'var(--speed-node-color)';
                    updateTimerDisplay();
                    
                    powerUpTimeout = setTimeout(() => {
                        notification.classList.remove('visible');
                    }, 3000);
                    break;
                    
                case 'bonus':
                    // Award bonus points
                    const bonusPoints = 50 * gameState.level;
                    gameState.score += bonusPoints;
                    notification.textContent = `Bonus: +${bonusPoints} Punkte!`;
                    notification.style.borderColor = 'var(--bonus-node-color)';
                    
                    // Show flying bonus text
                    showBonusPoints(bonusPoints);
                    
                    powerUpTimeout = setTimeout(() => {
                        notification.classList.remove('visible');
                    }, 3000);
                    break;
            }
            
            notification.classList.add('visible');
            updateUI();
        }
        
        function showBonusPoints(points) {
            const bonusText = document.createElement('div');
            bonusText.className = 'bonus-points';
            bonusText.textContent = `+${points}`;
            
            // Position near the center of the screen with random offset
            bonusText.style.left = `${50 + (Math.random() * 20 - 10)}%`;
            bonusText.style.top = `${50 + (Math.random() * 20 - 10)}%`;
            
            document.body.appendChild(bonusText);
            
            // Remove after animation completes
            setTimeout(() => {
                bonusText.remove();
            }, 1500);
        }

        function updateUI() {
            document.getElementById('score-display').textContent = `Score: ${gameState.score}`;
            document.getElementById('level-display').textContent = `Level ${gameState.level}`;
            
            // Update combo display
            const comboDisplay = document.getElementById('combo-display');
            if (gameState.combo > 0) {
                comboDisplay.textContent = `Combo: x${gameState.comboMultiplier.toFixed(1)}`;
                comboDisplay.classList.add('active');
            } else {
                comboDisplay.classList.remove('active');
            }
        }

        // --- Node Creation ---
        function createNodes(count) {
            const nodeGeometry = new THREE.IcosahedronGeometry(1.5, 1);
            const baseColor = new THREE.Color(0x00ffff);

            for (let i = 0; i < count; i++) {
                const nodeMaterial = new THREE.MeshStandardMaterial({
                    color: baseColor,
                    emissive: baseColor,
                    emissiveIntensity: 1.5,
                    metalness: 0.3,
                    roughness: 0.4,
                });

                const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
                node.position.set(
                    (Math.random() - 0.5) * 80,
                    (Math.random() - 0.5) * 60,
                    (Math.random() - 0.5) * 80
                );

                node.userData = {
                    id: `node_${i}`,
                    baseColor: baseColor.clone(),
                    hoverColor: new THREE.Color(0x00ffaa),
                    selectColor: new THREE.Color(0xff00ff),
                    baseEmissiveIntensity: 1.5,
                    hoverEmissiveIntensity: 3.0,
                    connectedTo: new Set(),
                    isTarget: false,
                    specialType: null
                };
                nodeDataMap.set(node.uuid, node.userData);

                scene.add(node);
                interactableNodes.push(node);
            }
        }

        // --- Background Particles ---
        function createBackgroundParticles() {
            const particleCount = 1500;
            const particleGeometry = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(particleCount * 3);
            const particleSizes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                particlePositions[i3] = (Math.random() - 0.5) * 200;
                particlePositions[i3 + 1] = (Math.random() - 0.5) * 200;
                particlePositions[i3 + 2] = (Math.random() - 0.5) * 200;
                particleSizes[i] = Math.random() * 2.0 + 0.5;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: 0x6088ff,
                size: 1.5,
                transparent: true,
                opacity: 0.7,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending
            });
            
            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // Add a second particle system for depth
            const particleSystem2Geometry = new THREE.BufferGeometry();
            const particleSystem2Positions = new Float32Array(particleCount * 3);
            const particleSystem2Sizes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                particleSystem2Positions[i3] = (Math.random() - 0.5) * 300;
                particleSystem2Positions[i3 + 1] = (Math.random() - 0.5) * 300;
                particleSystem2Positions[i3 + 2] = (Math.random() - 0.5) * 300;
                particleSystem2Sizes[i] = Math.random() * 1.0 + 0.2;
            }
            
            particleSystem2Geometry.setAttribute('position', new THREE.BufferAttribute(particleSystem2Positions, 3));
            particleSystem2Geometry.setAttribute('size', new THREE.BufferAttribute(particleSystem2Sizes, 1));
            
            const particleSystem2Material = new THREE.PointsMaterial({
                color: 0x2040ff,
                size: 0.8,
                transparent: true,
                opacity: 0.5,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending
            });
            
            particleSystem = new THREE.Points(particleSystem2Geometry, particleSystem2Material);
            scene.add(particleSystem);
        }

        // --- Connection Lines ---
        function createLine(startPos, endPos, color = 0x00ffaa, lineWidth = 2.5) {
            const points = [];
            points.push(startPos.x, startPos.y, startPos.z);
            points.push(endPos.x, endPos.y, endPos.z);
            
            const lineGeometry = new LineGeometry();
            lineGeometry.setPositions(points);
            
            const lineMaterial = new LineMaterial({
                color: color,
                linewidth: lineWidth,
                vertexColors: false,
                dashed: false,
                alphaToCoverage: true,
                resolution: new THREE.Vector2(window.innerWidth, window.innerHeight)
            });
            
            const line = new Line2(lineGeometry, lineMaterial);
            scene.add(line);
            return line;
        }

        function createConnection(nodeA, nodeB) {
            const connection = createLine(nodeA.position, nodeB.position, 0x00ffaa, 3.0);
            connection.userData = {
                nodeA: nodeA.uuid,
                nodeB: nodeB.uuid
            };
            
            permanentLines.push(connection);
            
            // Add to connected lists
            nodeA.userData.connectedTo.add(nodeB.uuid);
            nodeB.userData.connectedTo.add(nodeA.uuid);
            
            // Add to completed connections
            gameState.completedConnections.add(`${nodeA.uuid}-${nodeB.uuid}`);
            
            // Calculate score for this connection
            let connectionScore = 100;
            
            // Apply combo multiplier
            connectionScore *= gameState.comboMultiplier;
            
            // Apply double points power-up
            if (gameState.powerUps.doublePoints) {
                connectionScore *= 2;
            }
            
            // Apply difficulty multiplier
            connectionScore *= difficultySettings[gameState.difficulty].scoreMultiplier;
            
            // Add to total score
            gameState.score += Math.floor(connectionScore);
            
            // Update combo
            updateCombo();
            
            // Check for level completion
            checkLevelComplete();
            
            // Animate connection completion
            createConnectionParticles(nodeA.position, nodeB.position);
            
            // Show score popup
            if (connectionScore > 100) {
                showBonusPoints(Math.floor(connectionScore));
            }
        }

        function createConnectionParticles(startPos, endPos) {
            const particleCount = 50;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            const direction = new THREE.Vector3().subVectors(endPos, startPos);
            const length = direction.length();
            direction.normalize();
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const t = Math.random();
                const pos = new THREE.Vector3().copy(startPos).addScaledVector(direction, t * length);
                
                positions[i3] = pos.x;
                positions[i3 + 1] = pos.y;
                positions[i3 + 2] = pos.z;
                sizes[i] = Math.random() * 2.0 + 1.0;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const material = new THREE.PointsMaterial({
                color: 0x00ffaa,
                size: 2.0,
                transparent: true,
                opacity: 1.0,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending
            });
            
            const particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            
            // Animate particles
            const startTime = Date.now();
            const duration = 1000; // 1 second
            
            function animateParticles() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / duration;
                
                if (progress >= 1.0) {
                    scene.remove(particleSystem);
                    geometry.dispose();
                    material.dispose();
                    return;
                }
                
                material.opacity = 1.0 - progress;
                material.size = 2.0 + progress * 3.0;
                
                requestAnimationFrame(animateParticles);
            }
            
            animateParticles();
        }

        function updateActiveLine(position) {
            if (selectedNode && activeLine) {
                const positions = [];
                positions.push(
                    selectedNode.position.x, selectedNode.position.y, selectedNode.position.z,
                    position.x, position.y, position.z
                );
                activeLine.geometry.setPositions(positions);
                activeLine.geometry.attributes.position.needsUpdate = true;
                activeLine.computeLineDistances();
            }
        }

        function createActiveLine(start) {
            // Remove existing active line
            if (activeLine) {
                scene.remove(activeLine);
                activeLine.geometry.dispose();
                activeLine.material.dispose();
                activeLine = null;
            }
            
            const points = [];
            points.push(start.x, start.y, start.z);
            points.push(start.x, start.y, start.z); // Duplicate point initially
            
            const lineGeometry = new LineGeometry();
            lineGeometry.setPositions(points);
            
            const lineMaterial = new LineMaterial({
                color: 0xff00ff,
                linewidth: 3.0,
                vertexColors: false,
                dashed: true,
                dashSize: 0.3,
                gapSize: 0.1,
                resolution: new THREE.Vector2(window.innerWidth, window.innerHeight)
            });
            
            activeLine = new Line2(lineGeometry, lineMaterial);
            scene.add(activeLine);
        }

        // --- Interaction Handling ---
        function updateIntersections() {
            if (!pointerOverCanvas || gameState.isLevelComplete || gameState.tutorial) return;
            
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(interactableNodes);
            
            // Reset all nodes that aren't selected
            interactableNodes.forEach(node => {
                if (node !== selectedNode) {
                    node.material.emissiveIntensity = node.userData.baseEmissiveIntensity;
                    
                    if (node.userData.isTarget) {
                        // Make target nodes pulse with animation
                        const elapsedTime = clock.getElapsedTime();
                        const pulseIntensity = 1.5 + Math.sin(elapsedTime * 3) * 0.5;
                        node.material.emissiveIntensity = pulseIntensity;
                        
                        // Red glow for target nodes
                        node.material.color.set(0xff3030);
                        node.material.emissive.set(0xff0000);
                        
                        // Animate target nodes size
                        const scale = 1.0 + Math.sin(elapsedTime * 2) * 0.05;
                        node.scale.set(scale, scale, scale);
                    } else if (node.userData.specialType) {
                        // Special node animations
                        const elapsedTime = clock.getElapsedTime();
                        const pulseIntensity = 1.5 + Math.sin(elapsedTime * 3) * 0.5;
                        node.material.emissiveIntensity = pulseIntensity;
                        
                        // Set color based on special type
                        switch (node.userData.specialType) {
                            case 'power':
                                node.material.color.set(0xffaa00);
                                node.material.emissive.set(0xffaa00);
                                
                                // Add rotation animation
                                node.rotation.y = (elapsedTime * 0.5) % (Math.PI * 2);
                                break;
                                
                            case 'speed':
                                node.material.color.set(0x00ff00);
                                node.material.emissive.set(0x00ff00);
                                
                                // Add pulsing size animation
                                const scaleSpeed = 1.0 + Math.sin(elapsedTime * 4) * 0.1;
                                node.scale.set(scaleSpeed, scaleSpeed, scaleSpeed);
                                break;
                                
                            case 'bonus':
                                node.material.color.set(0xaa00ff);
                                node.material.emissive.set(0xaa00ff);
                                
                                // Add spinning animation
                                node.rotation.x = (elapsedTime * 0.3) % (Math.PI * 2);
                                node.rotation.z = (elapsedTime * 0.3) % (Math.PI * 2);
                                break;
                        }
                    } else {
                        node.scale.set(1, 1, 1);
                        node.rotation.set(0, 0, 0);
                        node.material.color.copy(node.userData.baseColor);
                        node.material.emissive.copy(node.userData.baseColor);
                    }
                }
            });
            
            // Clear previous hovered node
            if (hoveredNode && hoveredNode !== selectedNode && intersects.length === 0) {
                hoveredNode = null;
            }
            
            // Update hovered node
            if (intersects.length > 0) {
                const closestIntersect = intersects[0].object;
                
                // Skip if we're already handling this node as selected
                if (closestIntersect === selectedNode) return;
                
                hoveredNode = closestIntersect;
                
                // Apply hover effect
                if (!isDragging) {
                    closestIntersect.material.emissiveIntensity = closestIntersect.userData.hoverEmissiveIntensity;
                    
                    if (!closestIntersect.userData.isTarget && !closestIntersect.userData.specialType) {
                        closestIntersect.material.color.copy(closestIntersect.userData.hoverColor);
                        closestIntersect.material.emissive.copy(closestIntersect.userData.hoverColor);
                    }
                }
            }
        }

        function onPointerMove(event) {
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            if (isDragging && selectedNode) {
                raycaster.setFromCamera(mouse, camera);
                
                const planeNormal = camera.position.clone().sub(selectedNode.position).normalize();
                const plane = new THREE.Plane(planeNormal, -selectedNode.position.dot(planeNormal));
                
                const intersection = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersection);
                
                updateActiveLine(intersection);
            }
        }

        function onPointerDown(event) {
            if (gameState.tutorial || gameState.isLevelComplete) return;
            
            // Only handle left mouse button
            if (event.button !== 0) return;
            
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(interactableNodes);
            
            if (intersects.length > 0) {
                const selectedObject = intersects[0].object;
                
                // If it's a special node, activate its power-up
                if (selectedObject.userData.specialType) {
                    activatePowerUp(selectedObject.userData.specialType);
                    
                    // Reset the node to normal
                    selectedObject.userData.specialType = null;
                    selectedObject.material.color.copy(selectedObject.userData.baseColor);
                    selectedObject.material.emissive.copy(selectedObject.userData.baseColor);
                    selectedObject.material.emissiveIntensity = selectedObject.userData.baseEmissiveIntensity;
                    selectedObject.scale.set(1, 1, 1);
                    selectedObject.rotation.set(0, 0, 0);
                    
                    // Remove from special nodes list
                    Object.keys(gameState.specialNodes).forEach(type => {
                        gameState.specialNodes[type] = gameState.specialNodes[type].filter(
                            uuid => uuid !== selectedObject.uuid
                        );
                    });
                    
                    return;
                }
                
                // If it's a target node, start a connection
                if (selectedObject.userData.isTarget) {
                    controls.enabled = false;
                    isDragging = true;
                    selectedNode = selectedObject;
                    
                    // Apply selection effect
                    selectedNode.material.color.copy(selectedNode.userData.selectColor);
                    selectedNode.material.emissive.copy(selectedNode.userData.selectColor);
                    selectedNode.material.emissiveIntensity = 3.0;
                    
                    // Create active line for dragging
                    createActiveLine(selectedNode.position);
                }
            }
        }

        function onPointerUp(event) {
            if (!isDragging || !selectedNode) {
                controls.enabled = true;
                isDragging = false;
                return;
            }
            
            // Check if we're hovering over another target node
            if (hoveredNode && hoveredNode.userData.isTarget && hoveredNode !== selectedNode) {
                // Create permanent connection
                createConnection(selectedNode, hoveredNode);
            }
            
            // Reset state
            if (selectedNode) {
                selectedNode.material.color.copy(selectedNode.userData.baseColor);
                selectedNode.material.emissive.copy(selectedNode.userData.baseColor);
                selectedNode.material.emissiveIntensity = selectedNode.userData.baseEmissiveIntensity;
                selectedNode = null;
            }
            
            // Remove active line
            if (activeLine) {
                scene.remove(activeLine);
                activeLine.geometry.dispose();
                activeLine.material.dispose();
                activeLine = null;
            }
            
            controls.enabled = true;
            isDragging = false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            
            // Update line material resolutions
            permanentLines.forEach(line => {
                line.material.resolution.set(window.innerWidth, window.innerHeight);
            });
            
            if (activeLine) {
                activeLine.material.resolution.set(window.innerWidth, window.innerHeight);
            }
        }

        // --- Animation and Update Loop ---
        function animateParticles() {
            if (!particles || !particleSystem) return;
            
            const time = Date.now() * 0.00005;
            
            // Rotate first particle system slowly
            particles.rotation.y = time * 0.1;
            
            // Rotate second particle system in opposite direction
            particleSystem.rotation.y = -time * 0.05;
        }

        function animateTargetNodes() {
            const time = clock.getElapsedTime();
            
            interactableNodes.forEach(node => {
                if (node.userData.isTarget && node !== selectedNode) {
                    // Pulse effect for red glow
                    const pulseIntensity = 2.0 + Math.sin(time * 3 + node.position.x * 0.1) * 1.0;
                    node.material.emissiveIntensity = pulseIntensity;
                    
                    // Red glow for target nodes
                    node.material.color.set(0xff3030);
                    node.material.emissive.set(0xff0000);
                    
                    // Slightly stronger size animation
                    const scale = 1.0 + Math.sin(time * 2 + node.position.z * 0.1) * 0.08;
                    node.scale.set(scale, scale, scale);
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (!isInitialized) return;
            
            // Update controls
            controls.update();
            
            // Update interactions
            updateIntersections();
            
            // Animate nodes and particles
            animateParticles();
            animateTargetNodes();
            
            // Render scene
            composer.render();
        }

        // --- Initialization ---
        async function init() {
            try {
                // Scene setup
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x000000, 0.015);

                // Camera setup
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 10, 60);

                // Renderer setup
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.outputColorSpace = THREE.SRGBColorSpace;
                document.body.appendChild(renderer.domElement);

                // Controls setup
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.minDistance = 10;
                controls.maxDistance = 200;
                controls.enablePan = false;

                // Lighting setup
                const ambientLight = new THREE.AmbientLight(0x606060);
                scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
                dirLight.position.set(5, 10, 7);
                scene.add(dirLight);

                // Post-processing setup
                const renderScene = new RenderPass(scene, camera);
                const bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    1.5, 0.4, 0.85
                );
                bloomPass.threshold = 0.15;
                bloomPass.strength = 1.0;
                bloomPass.radius = 0.6;

                composer = new EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);

                // Interaction setup
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();

                // Create game elements
                createNodes(35);
                createBackgroundParticles();
                
                // Setup settings panel
                setupSettingsPanel();

                // Initialize game
                initializeLevel(1);
                showTutorial();

                // Event listeners
                window.addEventListener('resize', onWindowResize);
                renderer.domElement.addEventListener('pointermove', onPointerMove);
                renderer.domElement.addEventListener('pointerdown', onPointerDown);
                renderer.domElement.addEventListener('pointerup', onPointerUp);
                renderer.domElement.addEventListener('pointerleave', () => { pointerOverCanvas = false; });
                renderer.domElement.addEventListener('pointerenter', () => { pointerOverCanvas = true; });

                // Remove loading screen
                const loadingScreen = document.querySelector('.loading');
                if (loadingScreen) {
                    loadingScreen.style.opacity = 0;
                    setTimeout(() => {
                        loadingScreen.remove();
                    }, 500);
                }

                isInitialized = true;
                
                // Start animation
                animate();
            } catch (error) {
                console.error("Error initializing Aetherium:", error);
                document.body.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: var(--primary-color);">
                        <h2>Fehler beim Initialisieren von Aetherium</h2>
                        <p>Bitte versuche es erneut oder verwende einen neueren Browser.</p>
                        <p>${error.message}</p>
                    </div>
                `;
            }
        }

        // Start the game
        init();
    </script>
</body>
</html>
